# 目录

## 1. 概述

## 2. JVM
### 2.1. 线程 
### 2.2. JVM 内存区域 
#### 2.2.1. 程序计数器(线程私有)
#### 2.2.2. 虚拟机栈(线程私有)
#### 2.2.3. 本地方法区(线程私有)
#### 2.2.4. 堆（Heap-线程共享） -运行时数据区 
#### 2.2.5. 方法区/永久代（线程共享） 
### 2.3. JVM 运行时内存 
#### 2.3.1. 新生代 
##### 2.3.1.1. Eden 区
##### 2.3.1.2. ServivorFrom
##### 2.3.1.3. ServivorTo 
##### 2.3.1.4. MinorGC 的过程（复制->清空->互换） 
1： eden、 servicorFrom 复制到 ServicorTo，年龄+1
2：清空 eden、 servicorFrom
3： ServicorTo 和 ServicorFrom 互换
#### 2.3.2. 老年代 
#### 2.3.3. 永久代 
##### 2.3.3.1. JAVA8 与元数据
### 2.4. 垃圾回收与算法 
#### 2.4.1. 如何确定垃圾 
##### 2.4.1.1. 引用计数法
##### 2.4.1.2. 可达性分析
#### 2.4.2. 标记清除算法（Mark-Sweep） 
#### 2.4.3. 复制算法（copying） 
#### 2.4.4. 标记整理算法(Mark-Compact)
#### 2.4.5. 分代收集算法 
##### 2.4.5.1. 新生代与复制算法 
##### 2.4.5.2. 老年代与标记复制算法 
### 2.5. JAVA 四中引用类型 
#### 2.5.1. 强引用 
#### 2.5.2. 软引用 
#### 2.5.3. 弱引用 
#### 2.5.4. 虚引用 
### 2.6. GC 分代收集算法 VS 分区收集算法
#### 2.6.1. 分代收集算法 
##### 2.6.1.1. 在新生代-复制算法
##### 2.6.1.2. 在老年代-标记整理算法
#### 2.6.2. 分区收集算法 
### 2.7. GC 垃圾收集器 
#### 2.7.1. Serial 垃圾收集器（单线程、复制算法） 
#### 2.7.2. ParNew 垃圾收集器（Serial+多线程） 
#### 2.7.3. Parallel Scavenge 收集器（多线程复制算法、高效） 
#### 2.7.4. Serial Old 收集器（单线程标记整理算法 ） 
#### 2.7.5. Parallel Old 收集器（多线程标记整理算法） 
#### 2.7.6. CMS 收集器（多线程标记清除算法） 
##### 2.7.6.1. 初始标记
##### 2.7.6.2. 并发标记
##### 2.7.6.3. 重新标记
##### 2.7.6.4. 并发清除
#### 2.7.7. G1 收集器
### 2.8. JAVA IO/NIO
#### 2.8.1. 阻塞 IO 模型 
#### 2.8.2. 非阻塞 IO 模型 
#### 2.8.3. 多路复用 IO 模型 
#### 2.8.4. 信号驱动 IO 模型 
#### 2.8.5. 异步 IO 模型 
#### 2.8.1. JAVA IO 包
#### 2.8.2. JAVA NIO 
##### 2.8.2.1. NIO 的缓冲区 
##### 2.8.2.2. NIO 的非阻塞 
#### 2.8.3. Channel 
#### 2.8.4. Buffer
#### 2.8.5. Selector
### 2.9. JVM 类加载机制 
##### 2.9.1.1. 加载 
##### 2.9.1.2. 验证 
##### 2.9.1.3. 准备 
##### 2.9.1.4. 解析 
##### 2.9.1.5. 符号引用
##### 2.9.1.6. 直接引用
##### 2.9.1.7. 初始化 
##### 2.9.1.8. 类构造器<client>
#### 2.9.2. 类加载器 
##### 2.9.2.1. 启动类加载器(Bootstrap ClassLoader) 
##### 2.9.2.2. 扩展类加载器(Extension ClassLoader)
##### 2.9.2.3. 应用程序类加载器(Application ClassLoader)： 
#### 2.9.3. 双亲委派 
#### 2.9.4. OSGI（动态模型系统） 
##### 2.9.4.1. 动态改变构造
##### 2.9.4.2. 模块化编程与热插拔 
## 3. JAVA 集合
### 3.1. 接口继承关系和实现 
### 3.2. LIST
#### 3.2.1. ArrayList（数组） 
#### 3.2.2. Vector（数组实现、线程同步） 
#### 3.2.3. LinkList（链表） 
### 3.3. SET 
##### 3.3.1.1. HashSet（Hash 表） 
##### 3.3.1.2. TreeSet（二叉树） 
##### 3.3.1.3. LinkHashSet（HashSet+LinkedHashMap） 
### 3.4. MAP
#### 3.4.1. HashMap（数组+链表+红黑树） 
##### 3.4.1.1. JAVA7 实现 
##### 3.4.1.2. JAVA8 实现 
#### 3.4.2. ConcurrentHashMap
##### 3.4.2.1. Segment 段
##### 3.4.2.2. 线程安全（Segment 继承 ReentrantLock 加锁） 
##### 3.4.2.3. 并行度（默认 16） 
##### 3.4.2.4. Java8 实现 （引入了红黑树） 
#### 3.4.3. HashTable（线程安全） 
#### 3.4.4. TreeMap（可排序） 
#### 3.4.5. LinkHashMap（记录插入顺序） 
## 4. JAVA 多线程并发
#### 4.1.1. JAVA 并发知识库 
#### 4.1.2. JAVA 线程实现/创建方式 
##### 4.1.2.1. 继承 Thread 类
##### 4.1.2.2. 实现 Runnable 接口。 
##### 4.1.2.3. ExecutorService、 Callable<Class>、 Future 有返回值线程
##### 4.1.2.4. 基于线程池的方式
#### 4.1.3. 4 种线程池 
##### 4.1.3.1. newCachedThreadPool
##### 4.1.3.2. newFixedThreadPool
##### 4.1.3.3. newScheduledThreadPool
##### 4.1.3.4. newSingleThreadExecutor 
#### 4.1.4. 线程生命周期(状态)
##### 4.1.4.1. 新建状态（ NEW） 
##### 4.1.4.2. 就绪状态（ RUNNABLE）： 
##### 4.1.4.3. 运行状态（ RUNNING）： 
##### 4.1.4.4. 阻塞状态（ BLOCKED）： 
等待阻塞（ o.wait->等待对列）： 
同步阻塞(lock->锁池) 
其他阻塞(sleep/join) 
##### 4.1.4.5. 线程死亡（ DEAD） 
正常结束
异常结束
调用 stop
#### 4.1.5. 终止线程 4 种方式 
##### 4.1.5.1. 正常运行结束
##### 4.1.5.2. 使用退出标志退出线程
##### 4.1.5.3. Interrupt 方法结束线程
##### 4.1.5.4. stop 方法终止线程（线程不安全） 
#### 4.1.6. sleep 与 wait 区别
#### 4.1.7. start 与 run 区别 
#### 4.1.8. JAVA 后台线程 
#### 4.1.9. JAVA 锁 
##### 4.1.9.1. 乐观锁 
##### 4.1.9.2. 悲观锁 
##### 4.1.9.3. 自旋锁 
自旋锁的优缺点
自旋锁时间阈值（ 1.6 引入了适应性自旋锁） 
自旋锁的开启
##### 4.1.9.4. Synchronized 同步锁
Synchronized 作用范围
Synchronized 核心组件
Synchronized 实现
##### 4.1.9.5. ReentrantLock
Lock 接口的主要方法
非公平锁
公平锁
ReentrantLock 与 synchronized 
ReentrantLock 实现
Condition 类和 Object 类锁方法区别区别 
tryLock 和 lock 和 lockInterruptibly 的区别
##### 4.1.9.6. Semaphore 信号量 
实现互斥锁（计数器为 1） 
代码实现
Semaphore 与 ReentrantLock 
##### 4.1.9.7. AtomicInteger
##### 4.1.9.8. 可重入锁（递归锁） 
##### 4.1.9.9. 公平锁与非公平锁
公平锁（Fair） 
非公平锁（Nonfair） 
##### 4.1.9.10. ReadWriteLock 读写锁
读锁
写锁
##### 4.1.9.11. 共享锁和独占锁 
独占锁
共享锁
##### 4.1.9.12. 重量级锁（Mutex Lock） 
##### 4.1.9.13. 轻量级锁
锁升级
##### 4.1.9.14. 偏向锁
##### 4.1.9.15. 分段锁
##### 4.1.9.16. 锁优化
减少锁持有时间
减小锁粒度
锁分离
锁粗化
锁消除
#### 4.1.10. 线程基本方法 
##### 4.1.10.1. 线程等待（wait） 
##### 4.1.10.2. 线程睡眠（sleep） 
##### 4.1.10.3. 线程让步（yield） 
##### 4.1.10.4. 线程中断（interrupt） 
##### 4.1.10.5. Join 等待其他线程终止
##### 4.1.10.6. 为什么要用 join()方法？ 
##### 4.1.10.7. 线程唤醒（notify） 
##### 4.1.10.8. 其他方法： 
#### 4.1.11. 线程上下文切换 
##### 4.1.11.1. 进程
##### 4.1.11.2. 上下文
##### 4.1.11.3. 寄存器
##### 4.1.11.4. 程序计数器
##### 4.1.11.5. PCB-“切换桢” 
##### 4.1.11.6. 上下文切换的活动： 
##### 4.1.11.7. 引起线程上下文切换的原因 
#### 4.1.12. 同步锁与死锁 
##### 4.1.12.1. 同步锁
##### 4.1.12.2. 死锁
#### 4.1.13. 线程池原理 
##### 4.1.13.1. 线程复用
##### 4.1.13.2. 线程池的组成
##### 4.1.13.3. 拒绝策略
##### 4.1.13.4. Java 线程池工作过程 
#### 4.1.14. JAVA 阻塞队列原理
##### 4.1.14.1. 阻塞队列的主要方法 
插入操作： 
获取数据操作： 
##### 4.1.14.2. Java 中的阻塞队列 
##### 4.1.14.3. ArrayBlockingQueue（公平、非公平） 
##### 4.1.14.4. LinkedBlockingQueue（两个独立锁提高并发） 
##### 4.1.14.5. PriorityBlockingQueue（compareTo 排序实现优先） 
##### 4.1.14.6. DelayQueue（缓存失效、定时任务 ） 
##### 4.1.14.7. SynchronousQueue（不存储数据、可用于传递数据） 
##### 4.1.14.8. LinkedTransferQueue
##### 4.1.14.9. LinkedBlockingDeque
#### 4.1.15. CyclicBarrier、 CountDownLatch、 Semaphore 的用法
##### 4.1.15.1. CountDownLatch（线程计数器 ） 
##### 4.1.15.2. CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行） 
##### 4.1.15.3. Semaphore（信号量-控制同时访问的线程个数） 
#### 4.1.16. volatile 关键字的作用（变量可见性、禁止重排序） 
变量可见性
禁止重排序
比 sychronized 更轻量级的同步锁
适用场景
#### 4.1.17. 如何在两个线程之间共享数据
将数据抽象成一个类，并将数据的操作作为这个类的方法
Runnable 对象作为一个类的内部类 
#### 4.1.18. ThreadLocal 作用（线程本地存储） 
ThreadLocalMap（线程的一个属性） 
使用场景
#### 4.1.19. synchronized 和 ReentrantLock 的区别 
##### 4.1.19.1. 两者的共同点： 
##### 4.1.19.2. 两者的不同点： 
#### 4.1.20. ConcurrentHashMap 并发
##### 4.1.20.1. 减小锁粒度
##### 4.1.20.2. ConcurrentHashMap 分段锁
ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成
#### 4.1.21. Java 中用到的线程调度 
##### 4.1.21.1. 抢占式调度： 
##### 4.1.21.2. 协同式调度： 
##### 4.1.21.3. JVM 的线程调度实现（抢占式调度） 
##### 4.1.21.4. 线程让出 cpu 的情况： 
#### 4.1.22. 进程调度算法 
##### 4.1.22.1. 优先调度算法 
##### 4.1.22.2. 高优先权优先调度算法 
##### 4.1.22.3. 基于时间片的轮转调度算法 
#### 4.1.23. 什么是 CAS（比较并交换-乐观锁机制-锁自旋） 
##### 4.1.23.1. 概念及特性
##### 4.1.23.2. 原子包 java.util.concurrent.atomic（锁自旋） 
##### 4.1.23.3. ABA 问题
#### 4.1.24. 什么是 AQS（抽象的队列同步器） 
Exclusive 独占资源-ReentrantLock 
Share 共享资源-Semaphore/CountDownLatch 
同步器的实现是 ABS 核心（state 资源状态计数） 
ReentrantReadWriteLock 实现独占和共享两种方式
## 5. JAVA 基础
#### 5.1.1. JAVA 异常分类及处理
##### 5.1.1.1. 概念
##### 5.1.1.2. 异常分类
Error
Exception（RuntimeException、 CheckedException） 
##### 5.1.1.3. 异常的处理方式 
遇到问题不进行具体处理，而是继续抛给调用者 （throw,throws） 
try catch 捕获异常针对性处理方式
##### 5.1.1.4. Throw 和 throws 的区别： 
位置不同
功能不同： 
#### 5.1.2. JAVA 反射 
##### 5.1.2.1. 动态语言
##### 5.1.2.2. 反射机制概念 （运行状态中知道类所有的属性和方法） 
##### 5.1.2.3. 反射的应用场合 
编译时类型和运行时类型
的编译时类型无法获取具体方法
##### 5.1.2.4. Java 反射 API
反射 API 用来生成 JVM 中的类、接口或则对象的信息。 
##### 5.1.2.5. 反射使用步骤（获取 Class 对象、调用对象方法） 
##### 5.1.2.6. 获取 Class 对象的 3 种方法 
调用某个对象的 getClass()方法
调用某个类的 class 属性来获取该类对应的 Class 对象
使用 Class 类中的 forName()静态方法(最安全/性能最好)
##### 5.1.2.7. 创建对象的两种方法 
Class 对象的 newInstance()
调用 Constructor 对象的 newInstance()
#### 5.1.3. JAVA 注解 
##### 5.1.3.1. 概念 
##### 5.1.3.2. 4 种标准元注解
@Target 修饰的对象范围 
@Retention 定义 被保留的时间长短
@Documented 描述-javadoc
@Inherited 阐述了某个被标注的类型是被继承的 
##### 5.1.3.3. 注解处理器
#### 5.1.4. JAVA 内部类 
##### 5.1.4.1. 静态内部类
##### 5.1.4.2. 成员内部类
##### 5.1.4.3. 局部内部类（定义在方法中的类） 
##### 5.1.4.4. 匿名内部类（要继承一个父类或者实现一个接口、直接使用 new 来生成一个对象的引用） .....111
#### 5.1.5. JAVA 泛型 
##### 5.1.5.1. 泛型方法（<E>） 
##### 5.1.5.2. 泛型类<T> 
##### 5.1.5.3. 类型通配符? 
##### 5.1.5.4. 类型擦除 
#### 5.1.6. JAVA 序列化(创建可复用的 Java 对象)
保存(持久化)对象及其状态到内存或者磁盘
序列化对象以字节数组保持-静态成员不保存
序列化用户远程对象传输
Serializable 实现序列化 
ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化
writeObject 和 readObject 自定义序列化策略
序列化 ID
序列化并不保存静态变量
序列化子父类说明
Transient 关键字阻止该变量被序列化到文件中
#### 5.1.7. JAVA 复制 
##### 5.1.7.1. 直接赋值复制
##### 5.1.7.2. 浅复制（复制引用但不复制引用的对象） 
##### 5.1.7.3. 深复制（复制对象和其应用对象） 
##### 5.1.7.4. 序列化（深 clone 一中实现） 
## 6. SPRING 原理 
#### 6.1.1. Spring 特点
##### 6.1.1.1. 轻量级
##### 6.1.1.2. 控制反转
##### 6.1.1.3. 面向切面
##### 6.1.1.4. 容器
##### 6.1.1.5. 框架集合
#### 6.1.2. Spring 核心组件
#### 6.1.3. Spring 常用模块
#### 6.1.4. Spring 主要包
#### 6.1.5. Spring 常用注解
#### 6.1.6. Spring 第三方结合
#### 6.1.7. Spring IOC 原理
##### 6.1.7.1. 概念 
##### 6.1.7.2. Spring 容器高层视图 
##### 6.1.7.3. IOC 容器实现
BeanFactory-框架基础设施
###### 1 BeanDefinitionRegistry 注册表
###### 2 BeanFactory 顶层接口
###### 3 ListableBeanFactory 
###### 4 HierarchicalBeanFactory 父子级联
###### 5 ConfigurableBeanFactory
###### 6 AutowireCapableBeanFactory 自动装配 
###### 7 SingletonBeanRegistry 运行期间注册单例 Bean
###### 1.1..1.1.8 依赖日志框框
ApplicationContext 面向开发应用
WebApplication 体系架构 
##### 6.1.7.4. Spring Bean 作用域
singleton：单例模式（多线程下不安全） 
prototype:原型模式每次使用时创建 
Request：一次 request 一个实例
session
global Session
##### 6.1.7.5. Spring Bean 生命周期
实例化
IOC 依赖注入
setBeanName 实现
BeanFactoryAware 实现
ApplicationContextAware 实现
postProcessBeforeInitialization 接口实现-初始化预处理
init-method
postProcessAfterInitialization
Destroy 过期自动清理阶段 
destroy-method 自配置清理 
##### 6.1.7.6. Spring 依赖注入四种方式
构造器注入
setter 方法注入
静态工厂注入
实例工厂
##### 6.1.7.7. 5 种不同方式的自动装配
#### 6.1.8. Spring APO 原理 
##### 6.1.8.1. 概念 
##### 6.1.8.2. AOP 核心概念 
##### 6.1.8.1. AOP 两种代理方式 
JDK 动态接口代理 
CGLib 动态代理
##### 6.1.8.2. 实现原理 
#### 6.1.9. Spring MVC 原理
##### 6.1.9.1. MVC 流程
Http 请求到 DispatcherServlet 
HandlerMapping 寻找处理器
调用处理器 Controller
Controller 调用业务逻辑处理后，返回 ModelAndView
DispatcherServlet 查询 ModelAndView 
ModelAndView 反馈浏览器 HTTP 
##### 6.1.9.1. MVC 常用注解
#### 6.1.10. Spring Boot 原理
1. 创建独立的 Spring 应用程序
2. 嵌入的 Tomcat，无需部署 WAR 文件
3. 简化 Maven 配置
4. 自动配置 Spring 
5. 提供生产就绪型功能，如指标，健康检查和外部配置
6. 绝对没有代码生成和对 XML 没有要求配置 [1]
#### 6.1.11. JPA 原理
##### 6.1.11.1. 事务
##### 6.1.11.2. 本地事务
##### 6.1.11.1. 分布式事务
##### 6.1.11.1. 两阶段提交
1 准备阶段
2 提交阶段： 
#### 6.1.12. Mybatis 缓存
##### 6.1.12.1. Mybatis 的一级缓存原理（sqlsession 级别） 
##### 6.1.12.2. 二级缓存原理（mapper 基本） 
具体使用需要配置： 
#### 6.1.13. Tomcat 架构
## 7. 微服务 
#### 7.1.1. 服务注册发现 
##### 7.1.1.1. 客户端注册（zookeeper） 
##### 7.1.1.2. 第三方注册（独立的服务 Registrar） 
##### 7.1.1.3. 客户端发现
##### 7.1.1.4. 服务端发现
##### 7.1.1.5. Consul
##### 7.1.1.6. Eureka
##### 7.1.1.7. SmartStack
##### 7.1.1.8. Etcd 
#### 7.1.2. API 网关
##### 7.1.2.1. 请求转发 
##### 7.1.2.2. 响应合并 
##### 7.1.2.3. 协议转换 
##### 7.1.2.4. 数据转换 
##### 7.1.2.5. 安全认证 
#### 7.1.3. 配置中心 
##### 7.1.3.1. zookeeper 配置中心
##### 7.1.3.2. 配置中心数据分类
#### 7.1.4. 事件调度（kafka） 
#### 7.1.5. 服务跟踪（starter-sleuth） 
#### 7.1.6. 服务熔断（Hystrix） 
##### 7.1.6.1. Hystrix 断路器机制
#### 7.1.7. API 管理
## 8. NETTY 与 RPC 
#### 8.1.1. Netty 原理
#### 8.1.2. Netty 高性能
##### 8.1.2.1. 多路复用通讯方式 
##### 8.1.2.1. 异步通讯 NIO
##### 8.1.2.2. 零拷贝（DIRECT BUFFERS 使用堆外直接内存） 
##### 8.1.2.3. 内存池（基于内存池的缓冲区重用机制） 
##### 8.1.2.4. 高效的 Reactor 线程模型
Reactor 单线程模型
Reactor 多线程模型
主从 Reactor 多线程模型
##### 8.1.2.5. 无锁设计、线程绑定
##### 8.1.2.6. 高性能的序列化框架
小包封大包，防止网络阻塞
软中断 Hash 值和 CPU 绑定
#### 8.1.3. Netty RPC 实现
##### 8.1.3.1. 概念 
##### 8.1.3.2. 关键技术 
##### 8.1.3.3. 核心流程 
##### 8.1.3.1. 消息编解码
息数据结构（接口名称+方法名+参数类型和参数值+超时时间+ requestID） 
序列化
##### 8.1.3.1. 通讯过程 
核心问题(线程暂停、消息乱序) 
通讯流程
requestID 生成-AtomicLong 
存放回调对象 callback 到全局 ConcurrentHashMap 
synchronized 获取回调对象 callback 的锁并自旋 wait
监听消息的线程收到消息，找到 callback 上的锁并唤醒 
#### 8.1.4. RMI 实现方式
##### 8.1.4.1. 实现步骤 
#### 8.1.5. Protoclol Buffer 
##### 8.1.5.1. 特点 
#### 8.1.6. Thrift 
## 9. 网络
#### 9.1.1. 网络 7 层架构 
#### 9.1.2. TCP/IP 原理
##### 9.1.2.1. 网络访问层(Network Access Layer)
##### 9.1.2.2. 网络层(Internet Layer) 
##### 9.1.2.3. 传输层(Tramsport Layer-TCP/UDP) 
##### 9.1.2.4. 应用层(Application Layer)
#### 9.1.3. TCP 三次握手/四次挥手 
##### 9.1.3.1. 数据包说明
##### 9.1.3.2. 三次握手 
##### 9.1.3.3. 四次挥手 
#### 9.1.4. HTTP 原理
##### 9.1.4.1. 传输流程 
1：地址解析 
2：封装 HTTP 请求数据包 
3：封装成 TCP 包并建立连接
4：客户机发送请求命
5：服务器响应
6：服务器关闭 TCP 连接
##### 9.1.4.2. HTTP 状态 
##### 9.1.4.3. HTTPS 
建立连接获取证书
证书验证
数据加密和传输
#### 9.1.5. CDN 原理
##### 9.1.5.1. 分发服务系统
##### 9.1.5.2. 负载均衡系统： 
##### 9.1.5.3. 管理系统： 
## 10. 日志 
#### 10.1.1. Slf4j 
#### 10.1.2. Log4j 
#### 10.1.3. LogBack
##### 10.1.3.1. Logback 优点
#### 10.1.4. ELK
## 11. ZOOKEEPER 
#### 11.1.1. Zookeeper 概念 
#### 11.1.1. Zookeeper 角色 
##### 11.1.1.1. Leader 
##### 11.1.1.2. Follower
##### 11.1.1.3. Observer
##### 11.1.1.1. ZAB 协议 
事务编号 Zxid（事务请求计数器+ epoch） 
epoch
Zab 协议有两种模式-恢复模式（选主）、广播模式（同步） 
ZAB 协议 4 阶段
Leader election（选举阶段-选出准 Leader） 
Discovery（发现阶段-接受提议、生成 epoch、接受 epoch） 
Synchronization（同步阶段-同步 follower 副本） 
Broadcast（广播阶段-leader 消息广播） 
ZAB 协议 JAVA 实现（FLE-发现阶段和同步合并为 Recovery Phase（恢复阶段） ） 
##### 11.1.1.2. 投票机制
#### 11.1.2. Zookeeper 工作原理（原子广播） 
#### 11.1.3. Znode 有四种形式的目录节点 
## 12. KAFKA
#### 12.1.1. Kafka 概念 
#### 12.1.2. Kafka 数据存储设计 
##### 12.1.2.1. partition 的数据文件（offset， MessageSize， data） 
##### 12.1.2.2. 数据文件分段 segment（顺序读写、分段命令、二分查找） 
##### 12.1.2.3. 数据文件索引（分段索引、稀疏存储） 
#### 12.1.3. 生产者设计 
##### 12.1.3.1. 负载均衡（partition 会均衡分布到不同 broker 上） 
##### 12.1.3.2. 批量发送
##### 12.1.3.3. 压缩（GZIP 或 Snappy） 
#### 12.1.1. 消费者设计 
##### 12.1.1.1. Consumer Group 
## 13. RABBITMQ 
#### 13.1.1. 概念 
#### 13.1.2. RabbitMQ 架构 
##### 13.1.2.1. Message 
##### 13.1.2.2. Publisher 
##### 13.1.2.3. Exchange（将消息路由给队列 ） 
##### 13.1.2.4. Binding（消息队列和交换器之间的关联） 
##### 13.1.2.5. Queue 
##### 13.1.2.6. Connection 
##### 13.1.2.7. Channel 
##### 13.1.2.8. Consumer
##### 13.1.2.9. Virtual Host 
##### 13.1.2.10. Broker
#### 13.1.3. Exchange 类型 
##### 13.1.3.1. Direct 键（routing key）分布： 
##### 13.1.3.2. Fanout（广播分发） 
##### 13.1.3.3. topic 交换器（模式匹配） 
## 14. HBASE
#### 14.1.1. 概念 
#### 14.1.2. 列式存储 
#### 14.1.3. Hbase 核心概念
##### 14.1.3.1. Column Family 列族
##### 14.1.3.2. Rowkey（Rowkey 查询， Rowkey 范围扫描，全表扫描） 
##### 14.1.3.3. Region 分区
##### 14.1.3.4. TimeStamp 多版本
#### 14.1.4. Hbase 核心架构
##### 14.1.4.1. Client： 
##### 14.1.4.2. Zookeeper： 
##### 14.1.4.3. Hmaster
##### 14.1.4.4. HregionServer
##### 14.1.4.5. Region 寻址方式（通过 zookeeper .META） 
##### 14.1.4.6. HDFS 
#### 14.1.5. Hbase 的写逻辑
##### 14.1.5.1. Hbase 的写入流程 
获取 RegionServer 
请求写 Hlog 
请求写 MemStore 
##### 14.1.5.2. MemStore 刷盘
全局内存控制
MemStore 达到上限
RegionServer 的 Hlog 数量达到上限
手工触发
关闭 RegionServer 触发
Region 使用 HLOG 恢复完数据后触发
#### 14.1.6. HBase vs Cassandra
## 15. MONGODB
#### 15.1.1. 概念 
#### 15.1.2. 特点 
## 16. CASSANDRA
#### 16.1.1. 概念 
#### 16.1.2. 数据模型 
Key Space（对应 SQL 数据库中的 database） 
Key（对应 SQL 数据库中的主键） 
column（对应 SQL 数据库中的列） 
super column（SQL 数据库不支持） 
Standard Column Family（相对应 SQL 数据库中的 table） 
Super Column Family（SQL 数据库不支持） 
#### 16.1.3. Cassandra 一致 Hash 和虚拟节点 
一致性 Hash（多米诺 down 机） 
虚拟节点（down 机多节点托管） 
#### 16.1.4. Gossip 协议
Gossip 节点的通信方式及收敛性 
Gossip 两个节点（A、 B）之间存在三种通信方式（push、 pull、 push&pull） 
gossip 的协议和 seed list（防止集群分列） 
#### 16.1.5. 数据复制 
Partitioners（计算 primary key token 的 hash 函数） 
两种可用的复制策略： 
SimpleStrategy：仅用于单数据中心， 
将第一个 replica 放在由 partitioner 确定的节点中，其余的 replicas 放在上述节点顺时针方向的后续节
点中。 
NetworkTopologyStrategy：可用于较复杂的多数据中心。 
可以指定在每个数据中心分别存储多少份 replicas。 
#### 16.1.6. 数据写请求和协调者 
协调者(coordinator)
#### 16.1.7. 数据读请求和后台修复 
#### 16.1.8. 数据存储（CommitLog、 MemTable、 SSTable） 
SSTable 文件构成（ BloomFilter、 index、 data、 static） 
#### 16.1.9. 二级索引（对要索引的 value 摘要，生成 RowKey） 
#### 16.1.10. 数据读写 
数据写入和更新（数据追加） 
数据的写和删除效率极高
错误恢复简单
读的复杂度高
数据删除（ column 的墓碑） 
墓碑
垃圾回收 compaction 
数据读取（memtable+SStables） 
行缓存和键缓存请求流程图 
Row Cache（ SSTables 中频繁被访问的数据） 
Bloom Filter（查找数据可能对应的 SSTable） 
Partition Key Cache（查找数据可能对应的 Partition key） 
Partition Summary（内存中存储一些 partition index 的样本） 
Partition Index（磁盘中） 
Compression offset map（磁盘中） 
## 17. 设计模式
#### 17.1.1. 设计原则 
#### 17.1.2. 工厂方法模式 
#### 17.1.3. 抽象工厂模式 
#### 17.1.4. 单例模式 
#### 17.1.5. 建造者模式 
#### 17.1.6. 原型模式 
#### 17.1.7. 适配器模式 
#### 17.1.8. 装饰器模式 
#### 17.1.9. 代理模式 
#### 17.1.10. 外观模式 
#### 17.1.11. 桥接模式 
#### 17.1.12. 组合模式 
#### 17.1.13. 享元模式 
#### 17.1.14. 策略模式 
#### 17.1.15. 模板方法模式 
#### 17.1.16. 观察者模式 
#### 17.1.17. 迭代子模式 
#### 17.1.18. 责任链模式 
#### 17.1.19. 命令模式 
#### 17.1.20. 备忘录模式 
#### 17.1.21. 状态模式 
#### 17.1.22. 访问者模式 
#### 17.1.23. 中介者模式 
#### 17.1.24. 解释器模式 
## 18. 负载均衡
#### 18.1.1. 四层负载均衡 vs 七层负载均衡 
##### 18.1.1.1. 四层负载均衡（目标地址和端口交换） 
F5：硬件负载均衡器，功能很好，但是成本很高。 
lvs：重量级的四层负载软件。 
nginx：轻量级的四层负载软件，带缓存功能，正则表达式较灵活。 
haproxy：模拟四层转发，较灵活。 
##### 18.1.1.2. 七层负载均衡（内容交换） 
haproxy：天生负载均衡技能，全面支持七层代理，会话保持，标记，路径转移； 
nginx：只在 http 协议和 mail 协议上功能比较好，性能与 haproxy 差不多； 
apache：功能较差
Mysql proxy：功能尚可。 
#### 18.1.2. 负载均衡算法/策略 
##### 18.1.2.1. 轮循均衡（Round Robin） 
##### 18.1.2.2. 权重轮循均衡（Weighted Round Robin） 
##### 18.1.2.3. 随机均衡（Random） 
##### 18.1.2.4. 权重随机均衡（Weighted Random） 
##### 18.1.2.5. 响应速度均衡（Response Time 探测时间） 
##### 18.1.2.6. 最少连接数均衡（Least Connection） 
##### 18.1.2.7. 处理能力均衡（CPU、内存） 
##### 18.1.2.8. DNS 响应均衡（Flash DNS） 
##### 18.1.2.9. 哈希算法
##### 18.1.2.10. IP 地址散列（保证客户端服务器对应关系稳定） 
##### 18.1.2.11. URL 散列
#### 18.1.3. LVS
##### 18.1.3.1. LVS 原理
IPVS 
##### 18.1.3.1. LVS NAT 模式 
##### 18.1.3.2. LVS DR 模式（局域网改写 mac 地址） 
##### 18.1.3.3. LVS TUN 模式（ IP 封装、跨网段） 
##### 18.1.3.4. LVS FULLNAT 模式
#### 18.1.4. Keepalive
#### 18.1.5. Nginx 反向代理负载均衡 
##### 18.1.5.1. upstream_module 和健康检测
##### 18.1.5.1. proxy_pass 请求转发
#### 18.1.6. HAProxy 
## 19. 数据库 
#### 19.1.1. 存储引擎 
##### 19.1.1.1. 概念
##### 19.1.1.2. InnoDB（B+树） 
##### 19.1.1.3. TokuDB（Fractal Tree-节点带数据） 
##### 19.1.1.4. MyIASM
##### 19.1.1.5. Memory
#### 19.1.2. 索引 
##### 19.1.2.1. 常见索引原则有 
1.选择唯一性索引 
2.为经常需要排序、分组和联合操作的字段建立索引： 
3．为常作为查询条件的字段建立索引。 
4．限制索引的数目： 
尽量使用数据量少的索引
尽量使用前缀来索引
7．删除不再使用或者很少使用的索引 
8 . 最左前缀匹配原则，非常重要的原则。 
10 . 尽量选择区分度高的列作为索引 
11 .索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。 
12 .尽量的扩展索引，不要新建索引。 

#### 19.1.3. 数据库三范式 
##### 19.1.3.1. 第一范式(1st NF －列都是不可再分)
##### 19.1.3.2. 第二范式(2nd NF－每个表只描述一件事情)
##### 19.1.3.3. 第三范式(3rd NF－ 不存在对非主键列的传递依赖)
#### 19.1.4. 数据库是事务 
原子性（Atomicity） 
一致性（Consistency） 
隔离性（Isolation） 
永久性（Durability） 
#### 19.1.5. 存储过程(特定功能的 SQL 语句集)
存储过程优化思路： 
#### 19.1.6. 触发器(一段能自动执行的程序)
#### 19.1.7. 数据库并发策略 
##### 19.1.7.1. 乐观锁
##### 19.1.7.2. 悲观锁
##### 19.1.7.3. 时间戳
#### 19.1.8. 数据库锁 
##### 19.1.8.1. 行级锁
##### 19.1.8.2. 表级锁
##### 19.1.8.1. 页级锁
#### 19.1.9. 基于 Redis 分布式锁 
#### 19.1.10. 分区分表 
垂直切分(按照功能模块) 
水平切分(按照规则划分存储) 
#### 19.1.11. 两阶段提交协议 
##### 19.1.11.1. 准备阶段
##### 19.1.11.2. 提交阶段
##### 19.1.11.3. 缺点
同步阻塞问题
单点故障
数据不一致（脑裂问题） 
二阶段无法解决的问题（数据状态不确定） 
#### 19.1.12. 三阶段提交协议 
##### 19.1.12.1. CanCommit 阶段 
##### 19.1.12.2. PreCommit 阶段 
##### 19.1.12.3. doCommit 阶段
#### 19.1.13. 柔性事务 
##### 19.1.13.1. 柔性事务
两阶段型
补偿型
异步确保型
最大努力通知型（多次尝试） 
#### 19.1.14. CAP 
一致性（C）： 
可用性（A）： 
分区容忍性（P） ： 
## 20. 一致性算法
#### 20.1.1. Paxos 
Paxos 三种角色： Proposer， Acceptor， Learners 
Proposer： 
Acceptor： 
Learner： 
Paxos 算法分为两个阶段。具体如下： 
阶段一（准 leader 确定 ）： 
阶段二（leader 确认）： 
#### 20.1.2. Zab 
1.崩溃恢复：主要就是 Leader 选举过程

2.数据同步： Leader 服务器与其他服务器进行数据同步

3.消息广播： Leader 服务器将数据发送给其他服务器

#### 20.1.3. Raft
##### 20.1.3.1. 角色
Leader（领导者-日志管理） 
Follower（追随者-日志同步） 
Candidate（候选者-负责选票） 
##### 20.1.3.2. Term（任期） 
##### 20.1.3.3. 选举（ Election） 
选举定时器
##### 20.1.3.4. 安全性（ Safety） 
##### 20.1.3.5. raft 协议和 zab 协议区别 
#### 20.1.4. NWR
N：在分布式存储系统中，有多少份备份数据
W：代表一次成功的更新操作要求至少有 w 份数据写入成功 
R： 代表一次成功的读数据操作要求至少有 R 份数据成功读取
#### 20.1.5. Gossip
#### 20.1.6. 一致性 Hash
##### 20.1.6.1. 一致性 Hash 特性
##### 20.1.6.2. 一致性 Hash 原理
1.建构环形 hash 空间： 

2.把需要缓存的内容(对象)映射到 hash 空间

3.把服务器(节点)映射到 hash 空间 

4.把对象映射到服务节点

考察 cache 的变动
虚拟节点

## 21. JAVA 算法 
#### 21.1.1. 二分查找 
#### 21.1.2. 冒泡排序算法 
#### 21.1.3. 插入排序算法 
#### 21.1.4. 快速排序算法 
#### 21.1.1. 希尔排序算法 
#### 21.1.2. 归并排序算法 
#### 21.1.3. 桶排序算法 
#### 21.1.4. 基数排序算法 
#### 21.1.5. 剪枝算法 
#### 21.1.6. 回溯算法 
#### 21.1.7. 最短路径算法 
#### 21.1.8. 最大子数组算法 
#### 21.1.9. 最长公共子序算法 
#### 21.1.10. 最小生成树算法 
## 22. 数据结构
#### 22.1.1. 栈（ stack） 
#### 22.1.2. 队列（ queue） 
#### 22.1.3. 链表（ Link） 
#### 22.1.4. 散列表（ Hash Table） 
#### 22.1.5. 排序二叉树 
##### 22.1.5.1. 插入操作
##### 22.1.5.2. 删除操作
##### 22.1.5.3. 查询操作
#### 22.1.6. 红黑树 
##### 22.1.6.1. 红黑树的特性 
##### 22.1.6.1. 左旋
##### 22.1.6.1. 右旋
##### 22.1.6.1. 添加
##### 22.1.6.2. 删除
#### 22.1.7. B-TREE
#### 22.1.8. 位图 
## 23. 加密算法
#### 23.1.1. AES 
#### 23.1.2. RSA
#### 23.1.3. CRC
#### 23.1.4. MD5
## 24. 分布式缓存
#### 24.1.1. 缓存雪崩 
#### 24.1.2. 缓存穿透 
#### 24.1.3. 缓存预热 
#### 24.1.4. 缓存更新 
#### 24.1.5. 缓存降级 
## 25. HADOOP 
#### 25.1.1. 概念 
#### 25.1.2. HDFS 
##### 25.1.2.1. Client
##### 25.1.2.2. NameNode
##### 25.1.2.3. Secondary NameNode 
##### 25.1.2.4. DataNode
#### 25.1.3. MapReduce
##### 25.1.3.1. Client
##### 25.1.3.2. JobTracker 
##### 25.1.3.3. TaskTracker
##### 25.1.3.4. Task 
##### 25.1.3.5. Reduce Task 执行过程 
#### 25.1.4. Hadoop MapReduce 作业的生命周期
1.作业提交与初始化

2.任务调度与监控。 

3.任务运行环境准备

4.任务执行 

5.作业完成。 

## 26. SPARK
#### 26.1.1. 概念 
#### 26.1.2. 核心架构 
Spark Core 
Spark SQL 
Spark Streaming
Mllib 
GraphX
#### 26.1.3. 核心组件 
Cluster Manager-制整个集群，监控 worker 
Worker 节点-负责控制计算节点
Driver： 运行 Application 的 main()函数
Executor：执行器，是为某个 Application 运行在 worker node 上的一个进程
#### 26.1.4. SPARK 编程模型
#### 26.1.5. SPARK 计算模型
#### 26.1.6. SPARK 运行流程
1. 构建 Spark Application 的运行环境，启动 SparkContext
2. SparkContext 向资源管理器（可以是 Standalone， Mesos， Yarn）申请运行 Executor 资源，并启
动 StandaloneExecutorbackend， 
3. Executor 向 SparkContext 申请 Task
4. SparkContext 将应用程序分发给 Executor
5. SparkContext 构建成 DAG 图，将 DAG 图分解成 Stage、将 Taskset 发送给 Task Scheduler，最
后由 Task Scheduler 将 Task 发送给 Executor 运行
6. Task 在 Executor 上运行，运行完释放所有资源
#### 26.1.7. SPARK RDD 流程 
#### 26.1.8. SPARK RDD
（1） RDD 的创建方式
（2） RDD 的两种操作算子（转换（Transformation）与行动（Action） ） 
## 27. STORM 
#### 27.1.1. 概念 
#### 27.1.1. 集群架构 
##### 27.1.1.1. Nimbus（master-代码分发给 Supervisor） 
##### 27.1.1.2. Supervisor（slave-管理 Worker 进程的启动和终止） 
##### 27.1.1.3. Worker（具体处理组件逻辑的进程） 
##### 27.1.1.4. Task 
##### 27.1.1.5. ZooKeeper 
#### 27.1.2. 编程模型（spout->tuple->bolt） 
##### 27.1.2.1. Topology
##### 27.1.2.2. Spout
##### 27.1.2.3. Bolt
##### 27.1.2.4. Tuple
##### 27.1.2.5. Stream 
#### 27.1.3. Topology 运行
(1). Worker（进程） (2). Executor（线程） (3). Task
##### 27.1.3.1. Worker(1 个 worker 进程执行的是 1 个 topology 的子集) 
##### 27.1.3.2. Executor(executor 是 1 个被 worker 进程启动的单独线程)
##### 27.1.3.3. Task(最终运行 spout 或 bolt 中代码的单元)
#### 27.1.4. Storm Streaming Grouping
##### 27.1.4.1. huffle Grouping
##### 27.1.4.2. Fields Grouping
##### 27.1.4.3. All grouping ：广播
##### 27.1.4.4. Global grouping
##### 27.1.4.5. None grouping ：不分组
##### 27.1.4.6. Direct grouping ：直接分组 指定分组 
## 28. YARN 
#### 28.1.1. 概念 
#### 28.1.2. ResourceManager 
#### 28.1.3. NodeManager 
#### 28.1.4. ApplicationMaster 
#### 28.1.5. YARN 运行流程 
## 29. 机器学习
#### 29.1.1. 决策树 
#### 29.1.2. 随机森林算法 
#### 29.1.3. 逻辑回归 
#### 29.1.4. SVM
#### 29.1.5. 朴素贝叶斯 
#### 29.1.6. K 最近邻算法
#### 29.1.7. K 均值算法
#### 29.1.8. Adaboost 算法 
#### 29.1.9. 神经网络 
#### 29.1.10. 马尔可夫 
## 30. 云计算 
#### 30.1.1. SaaS 
#### 30.1.2. PaaS 
#### 30.1.3. IaaS
#### 30.1.4. Docker
##### 30.1.4.1. 概念
##### 30.1.4.2. Namespaces
##### 30.1.4.3. 进程(CLONE_NEWPID 实现的进程隔离)
##### 30.1.4.4. Libnetwork 与网络隔离
##### 30.1.4.5. 资源隔离与 CGroups 
##### 30.1.4.6. 镜像与 UnionFS
##### 30.1.4.7. 存储驱动
#### 30.1.5. Openstack 
